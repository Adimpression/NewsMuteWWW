goog.provide("ngmaterial.components.sidenav");goog.require("ngmaterial.components.backdrop");goog.require("ngmaterial.core");SidenavService.$inject=["$mdComponentRegistry","$mdUtil","$q","$log"];SidenavDirective.$inject=["$mdMedia","$mdUtil","$mdConstant","$mdTheming","$animate","$compile","$parse","$log","$q","$document"];SidenavController.$inject=["$scope","$element","$attrs","$mdComponentRegistry","$q"];angular.module("material.components.sidenav",["material.core","material.components.backdrop"]).factory("$mdSidenav",SidenavService).directive("mdSidenav",SidenavDirective).directive("mdSidenavFocus",SidenavFocusDirective).controller("$mdSidenavController",SidenavController);function SidenavService($mdComponentRegistry,$mdUtil,$q,$log){var errorMsg="SideNav '{0}' is not available! Did you use md-component-id='{0}'?";var service={find:findInstance,waitFor:waitForInstance};return function(handle,enableWait){if(angular.isUndefined(handle))return service;var shouldWait=enableWait===true;var instance=service.find(handle,shouldWait);return!instance&&shouldWait?service.waitFor(handle):!instance&&angular.isUndefined(enableWait)?addLegacyAPI(service,handle):instance};function addLegacyAPI(service,handle){var falseFn=function(){return false};var rejectFn=function(){return $q.when($mdUtil.supplant(errorMsg,[handle||""]))};return angular.extend({isLockedOpen:falseFn,isOpen:falseFn,toggle:rejectFn,open:rejectFn,close:rejectFn,onClose:angular.noop,then:function(callback){return waitForInstance(handle).then(callback||angular.noop)}},service)}function findInstance(handle,shouldWait){var instance=$mdComponentRegistry.get(handle);if(!instance&&!shouldWait){$log.error($mdUtil.supplant(errorMsg,[handle||""]));return undefined}return instance}function waitForInstance(handle){return $mdComponentRegistry.when(handle).catch($log.error)}}function SidenavFocusDirective(){return{restrict:"A",require:"^mdSidenav",link:function(scope,element,attr,sidenavCtrl){}}}function SidenavDirective($mdMedia,$mdUtil,$mdConstant,$mdTheming,$animate,$compile,$parse,$log,$q,$document){return{restrict:"E",scope:{isOpen:"=?mdIsOpen"},controller:"$mdSidenavController",compile:function(element){element.addClass("md-closed");element.attr("tabIndex","-1");return postLink}};function postLink(scope,element,attr,sidenavCtrl){var lastParentOverFlow;var backdrop;var disableScrollTarget=null;var triggeringElement=null;var previousContainerStyles;var promise=$q.when(true);var isLockedOpenParsed=$parse(attr.mdIsLockedOpen);var isLocked=function(){return isLockedOpenParsed(scope.$parent,{$media:function(arg){$log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");return $mdMedia(arg)},$mdMedia:$mdMedia})};if(attr.mdDisableScrollTarget){disableScrollTarget=$document[0].querySelector(attr.mdDisableScrollTarget);if(disableScrollTarget){disableScrollTarget=angular.element(disableScrollTarget)}else{$log.warn($mdUtil.supplant("mdSidenav: couldn't find element matching "+'selector "{selector}". Falling back to parent.',{selector:attr.mdDisableScrollTarget}))}}if(!disableScrollTarget){disableScrollTarget=element.parent()}if(!attr.hasOwnProperty("mdDisableBackdrop")){backdrop=$mdUtil.createBackdrop(scope,"md-sidenav-backdrop md-opaque ng-enter")}element.addClass("_md");$mdTheming(element);if(backdrop)$mdTheming.inherit(backdrop,element);element.on("$destroy",function(){backdrop&&backdrop.remove();sidenavCtrl.destroy()});scope.$on("$destroy",function(){backdrop&&backdrop.remove()});scope.$watch(isLocked,updateIsLocked);scope.$watch("isOpen",updateIsOpen);sidenavCtrl.$toggleOpen=toggleOpen;function updateIsLocked(isLocked,oldValue){scope.isLockedOpen=isLocked;if(isLocked===oldValue){element.toggleClass("md-locked-open",!!isLocked)}else{$animate[isLocked?"addClass":"removeClass"](element,"md-locked-open")}if(backdrop){backdrop.toggleClass("md-locked-open",!!isLocked)}}function updateIsOpen(isOpen){var focusEl=$mdUtil.findFocusTarget(element)||$mdUtil.findFocusTarget(element,"[md-sidenav-focus]")||element;var parent=element.parent();parent[isOpen?"on":"off"]("keydown",onKeyDown);if(backdrop)backdrop[isOpen?"on":"off"]("click",close);var restorePositioning=updateContainerPositions(parent,isOpen);if(isOpen){triggeringElement=$document[0].activeElement}disableParentScroll(isOpen);return promise=$q.all([isOpen&&backdrop?$animate.enter(backdrop,parent):backdrop?$animate.leave(backdrop):$q.when(true),$animate[isOpen?"removeClass":"addClass"](element,"md-closed")]).then(function(){if(scope.isOpen){focusEl&&focusEl.focus()}restorePositioning&&restorePositioning()})}function updateContainerPositions(parent,willOpen){var drawerEl=element[0];var scrollTop=parent[0].scrollTop;if(willOpen&&scrollTop){previousContainerStyles={top:drawerEl.style.top,bottom:drawerEl.style.bottom,height:drawerEl.style.height};var positionStyle={top:scrollTop+"px",bottom:"auto",height:parent[0].clientHeight+"px"};element.css(positionStyle);backdrop.css(positionStyle)}if(!willOpen&&previousContainerStyles){return function(){drawerEl.style.top=previousContainerStyles.top;drawerEl.style.bottom=previousContainerStyles.bottom;drawerEl.style.height=previousContainerStyles.height;backdrop[0].style.top=null;backdrop[0].style.bottom=null;backdrop[0].style.height=null;previousContainerStyles=null}}}function disableParentScroll(disabled){if(disabled&&!lastParentOverFlow){lastParentOverFlow=disableScrollTarget.css("overflow");disableScrollTarget.css("overflow","hidden")}else if(angular.isDefined(lastParentOverFlow)){disableScrollTarget.css("overflow",lastParentOverFlow);lastParentOverFlow=undefined}}function toggleOpen(isOpen){if(scope.isOpen==isOpen){return $q.when(true)}else{if(scope.isOpen&&sidenavCtrl.onCloseCb)sidenavCtrl.onCloseCb();return $q(function(resolve){scope.isOpen=isOpen;$mdUtil.nextTick(function(){promise.then(function(result){if(!scope.isOpen){triggeringElement&&triggeringElement.focus();triggeringElement=null}resolve(result)})})})}}function onKeyDown(ev){var isEscape=ev.keyCode===$mdConstant.KEY_CODE.ESCAPE;return isEscape?close(ev):$q.when(true)}function close(ev){ev.preventDefault();return sidenavCtrl.close()}}}function SidenavController($scope,$element,$attrs,$mdComponentRegistry,$q){var self=this;self.isOpen=function(){return!!$scope.isOpen};self.isLockedOpen=function(){return!!$scope.isLockedOpen};self.onClose=function(callback){self.onCloseCb=callback;return self};self.open=function(){return self.$toggleOpen(true)};self.close=function(){return self.$toggleOpen(false)};self.toggle=function(){return self.$toggleOpen(!$scope.isOpen)};self.$toggleOpen=function(value){return $q.when($scope.isOpen=value)};self.destroy=$mdComponentRegistry.register(self,$attrs.mdComponentId)}ngmaterial.components.sidenav=angular.module("material.components.sidenav");